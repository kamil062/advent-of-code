export { };

let input = `.##.####.#.#..###....##.....#.#.#.###.#####..#..#...#..#.##.##.#..#####.#.
#.#..####..#...#.####..#.#..##.###..#.#...#.#..##..##.#...#..#####.#.####.
.#.#.####..##.##.#..###..#..#...#.##..#.#.###....####..#..#.#...#.#..##...
#..###..#..#.#.##.#...#.#.#.#.#....##..##.##.##...#..##.....##...#...##...
#...##..#.####.#.#.#########.###..#.##.####.#.###..##..#.#.#.#..#.######..
#.#..##..#.###.##..#.#....#####...##.....#...#.#....#.###.#.#.#..##..#####
#..###.##.#.##..#..#.##...##.##.##....#..#...#.##.#.#.#..#.###.#...#..###.
.###.##.#..##...###...#.#.#..######..##..###..###....#...#.#.##.#.#.#..#..
.#.#.##.#####..####..###..###.#..######...........##......#...#..##..#....
###.#....##.#.#.#.#...#.##.##...######.##.#..#####.##.##...#....##....###.
####.##..#.###....#.##.#..#.#..##.##..#.####...#.###...###..#..##..#....##
......#....##.#..#.##...#...##....#.###.#.#.####.###...#..###....#..#.#...
............#.###.##...#.#...##.#...#.####......#.###..####.######.#....##
.##.#.#..#.####..#####.....#..#.#..##..#.##.#..##.#.#.#..#.#.###..####.###
.###...###.#.#.###.##..##.#..###...#####..#.....#...#.##.##...#.##...#####
##..##...#...#.....#.#.####......#..#..#..#...#.#.##.##.#####.#.###.#...##
..##.#..#..##.#....##.##.#......######....#.##.#.####..#...###.####.#.#..#
..#..##...#...###.....#.##..#..##..#.##..#..###..#..#.#..#...#...##..#.#..
#...###...####.#.#..##.##.#.#.##..#.#.#.#..##.###..##..#..####.#..####.##.
###..#.#..###.###.######.#..#.###.......######.####.###...##.#.##.##..###.
#.###.#...#.####.#.####..##..###....#####..#.#.###..#.##.###..#..####.#...
#.######..##..##.#######.#.#.##..##.###########.#.##.###...........#....##
#.####...##..#.##...##.#..##.#..#.####.#.#.##..#..##.####...#...#..#.####.
.#####.###.#.#....###.#...#.####...#.###...#..##.#.#.####..#....#######...
#...#.#.##.......#.###..###....###.#..#..#...###...###...##....#...######.
..##..##....#.#..########....#..#.#....###.#..#..#..#..##.......##....#..#
.###...##....##..#..##...##..#..###..##.#..##...##..##...##....##...#.##.#
.#...#..#..#..##..#..#####..#..##.##.#.#.#.####.#..###.###...#...#..#.####
#.#.#.#.#..##..##..#.######.###..#..####.##..####.#..#...#...##.#..###....
.##..####.##.#.####.#..#.####..#.#.#.###.###..#.#.#.#..##....##.###.##..#.
.#.#.#.....###.#######.....###..#.####.#.#.##...#.######.#.#..###.##.#.#.#
.#.#......#.....##.##.###.#..###...####...#.#.#..###.####..#..#.#.####.#.#
#...###......########....#######.....#..##.#...#...####..#.#..#..#.##.#..#
.#.#.#..##..##...#.#..##.##.#.##.#####.#..#.#.#.#.#..##...##.####....###..
#..#....##....#.#.#####..###.#..........###.......#.###.#.#.#.#######.###.
#.###.##..#......##.#.#.##.#....###...#...####.##.##...#.##..#.#.#######.#
###....#...###.##.##.#..###.#.####.##..#...####.##..#.###.#..#..#.#.#..#.#
.##...##......#.#####.....#.######.#.#..#...###..##.###..##..#.###.#.#.#..
.#.##...##..#....#...#..#..##...###.#.#.####..##...#..#....#..###.#..##..#
..##....#....######..#..#.###.#....##.###.###....##...##.##.#..#..##.....#
##..#.#.##.#....#..###..##.#.#.###.#.#######.#.#.####.#....##...#.#.###...
#...##.#...####...##..#..#....#..##...#...#.#....#..#..##..#..#..##.#.....
#.#.#.####......###....#...#..#.#.#######.#..#..##.....#...#....#..###..#.
#.##.##..##.#.#..#...#....####.##..#.#.##..#..##.####..#.#..#....#.##.#..#
..####.##.#####...#.##.#...##.##.##.##.#..##..#.##.##..###..##..##....###.
..##...#.#.#....#.#.#.###....#.#.#..######.#.##..###....#.####..###..##..#
.#.....##.#..#.#.##..##.##.#...#.###.###.##.#..###.#.......#.#.#..#..#..#.
.....#.#.#.##.#.#..#....#####...#...##..####...#...#.#......#.#...#.#.####
#.#####......###..#......#.....#####..#...#.#.#..##.#..#...#....##..#.##..
.##.###.###..###...#..########.#.#.##...##.##..##....#....#..#.#.####.##.#
#.##....#...#.#...#......###.#.#.....#.#.###.####.##.###...##...##...#.##.
..##.###.#.#...#...##...##..#####...#.####.##..###.#.#...#..#.......###.#.
.####.###..##.#..#..#..#.#...#...#..#......#.##.#.##.#.###.#.#..#.##.###..
..#####..#.#.......#.####.#.#.#.#...##.....###..#..###...##.##.#########.#
#.#..#.#.#..##..#........##..#..#.##.#.#...#.##.#.##...####.###.###.#.#.#.
...#..###.#.#.###.##..#.#...#.#.#.##....#.#..####.#.##.##.###.###.##.##.##
#.#.#.#...#.#.##.#.##.#.....####........#..########...#.##.########.#...##
...####......###.#...###..##.#.#.#####..#....##.#.#.##.#######.#......##..
##.##.##.##......###.#.##..##.##..#...#.##.#.#.##.#.....#...#.#........#..
#..###...#.#..#####.#.#####....#..###.....#.#..######...#.#####...##..#.##
#...#..#..#...#.#.#..#..##...#.#..#.....###..####..#......#.#...#.#.#.#.#.
...###.#.#...####....#.#...#.##..##.#.##.#..##..#...#.#.##..#.#..........#
###......#############..#.##..#....##....#...#.#...##..##..##..##.##.#...#
.#..##.##..#.####.#..###..###.#...#.##.##..#.#.#.##.#..........##...###.#.
#.##.#####..#.##.#.#####......#....###.#.....###.#......#....##.#####.##.#
###.....#.#...######.##.#..##.#....#...#..#.###.###.##.##........#.#..#..#
..####.#.##.#.###.##...##.#.#...#.##.##.####.##...#....#...#..##..###...#.
#..#.##.#.##.###.####.#.#.###.####.#..##..####.#.#.#.####.#.#.#....##..#.#
#.###.##..#.####.#....#..#....##.#..#..###....###..##.##....###...###.##.#
###.#..####..#.#......#...#.#..##.#######.#.#.###..#.#......###.##.#####..
#....#.....#.#.#..##.#...#......#.....#..#..##.###...######.#.##....####.#
..#.##..##.##.#..##.#.#.#####.#...#..#..#.#..#.#.#..#.##..##.............#
....#.#.#.#....#......##.###.#.###.##..####..#.#.##..#.###..####....##.#..
##...##...######.#.#.#.#.#.#..#....#..####...#.#.#.#.###.#.#.##.#.#.##..##`;

// input = `.....
// ..##.
// ..#..
// .....
// ..##.
// .....`;

input = `..............
..............
.......#......
.....###.#....
...#...#.#....
....#...##....
...#.###......
...##.#.##....
....#..#......
..............
..............
..............`;

type Direction = 'north' | 'south' | 'west' | 'east';
type Queue = { position: Position, direction: Direction }[];

class Position {
    constructor(
        public x: number,
        public y: number
    ) { }

    translate(position: Position | { x: number, y: number }) {
        return new Position(
            this.x + position.x,
            this.y + position.y
        )
    }

    positions(direction: Direction) {
        let [SW, W, NW, S, N, SE, E, NE] = this.adjacentPositions();

        switch (direction) {
            case 'north': return [N, NE, NW];
            case 'south': return [S, SE, SW];
            case 'west': return [W, NW, SW];
            case 'east': return [E, NE, SE];
        }
    }

    adjacentPositions() {
        return [
            this.translate({ x: -1, y: -1 }),   // SW
            this.translate({ x: -1, y: 0 }),    // W
            this.translate({ x: -1, y: 1 }),    // NW
            this.translate({ x: 0, y: -1 }),    // S
            this.translate({ x: 0, y: 1 }),     // N
            this.translate({ x: 1, y: -1 }),    // SE
            this.translate({ x: 1, y: 0 }),     // E
            this.translate({ x: 1, y: 1 }),     // NE
        ]
    }

    equals(position: Position) {
        return this.x == position.x && this.y == position.y;
    }
}

const parseInput = (input: string) => {
    return input
        .split('\n')
        .reverse()
        .map((line, y) => {
            return line
                .split('')
                .map((cell, x) => {
                    return cell == '#'
                        ? new Position(x, y)
                        : null;
                })
        })
        .flat()
        .filter(elf => elf != null) as NonNullable<Position[]>;
}

const freePositions = (positions: Position[], elvesPositions: Position[]) => {
    return positions.filter(position => {
        return !elvesPositions.some(elve => elve.equals(position))
    });
}

const proposePosition = (elfPosition: Position, elvesPositions: Position[], queue: Queue): Position | null => {
    let adjacentPositions = elfPosition.adjacentPositions();

    let availablePositions = freePositions(adjacentPositions, elvesPositions);

    if (availablePositions.length == 8) return null;

    for (let direction of queue) {
        let proposition = elfPosition.positions(direction.direction);
        let available = freePositions(proposition, elvesPositions);

        if (available.length == proposition.length) {
            return elfPosition.translate(direction.position)
        }
    }

    return null;
}

const round = (elvesPositions: Position[], queue: Queue) => {
    let proposedPositions = elvesPositions
        .map(position => {
            return {
                elf: position,
                nextPosition: proposePosition(position, elvesPositions, queue)
            }
        })
        .filter(position => position.nextPosition != null);

    proposedPositions = proposedPositions.filter(proposition => {
        return proposedPositions.filter(p => p.nextPosition?.equals(proposition.nextPosition as NonNullable<Position>)).length == 1;
    });


    for (let position of proposedPositions) {
        position.elf.x = (position.nextPosition as NonNullable<Position>).x;
        position.elf.y = (position.nextPosition as NonNullable<Position>).y;
    }

    queue.push(queue.shift() as NonNullable<any>);

    return proposedPositions.length;
}

const drawPositions = (elvesPositions: Position[], margin: number, disableConsoleLog: boolean) => {
    let minX = elvesPositions.reduce((a, b) => Math.min(a, b.x), Infinity) - margin;
    let maxX = elvesPositions.reduce((a, b) => Math.max(a, b.x), -Infinity) + margin;
    let minY = elvesPositions.reduce((a, b) => Math.min(a, b.y), Infinity) - margin;
    let maxY = elvesPositions.reduce((a, b) => Math.max(a, b.y), -Infinity) + margin;

    let w = maxX - minX + 1;
    let h = maxY - minY + 1;

    let map = Array(h).fill(null).map(() => {
        return Array(w).fill('.');
    });

    for (let position of elvesPositions) {
        map[position.y - minY][position.x - minX] = "#"
    }

    if (disableConsoleLog == false) {
        console.log(
            "\n" +
            map.reverse().map(row => row.join('')).join('\n')
            + "\n"
        )
    }

    return map.flat().filter(cell => cell == '.').length;
}

const scatter = (elvesPositions: Position[], rounds: number, queue: Queue) => {
    for (let i = 1; i <= rounds; i++) {
        round(elvesPositions, queue);
        console.log(`Round ${i}`);
    }

    return drawPositions(elvesPositions, 0, true);
}

const scatterUntilNoMovement = (elvesPositions: Position[], queue: Queue) => {
    for (let i = 1; ; i++) {
        let numberOfMoves = round(elvesPositions, queue);
        console.log(`Round ${i} => ${numberOfMoves}`);

        if (numberOfMoves == 0) return i;
    }
}

{
    console.clear();

    {
        const queue: Queue = [
            { position: new Position(0, 1), direction: 'north' },
            { position: new Position(0, -1), direction: 'south' },
            { position: new Position(-1, 0), direction: 'west' },
            { position: new Position(1, 0), direction: 'east' }
        ]

        let elvesPositions1 = parseInput(input);

        console.log({
            part1: scatter(elvesPositions1, 10, queue),
        })
    }

    {
        const queue: Queue = [
            { position: new Position(0, 1), direction: 'north' },
            { position: new Position(0, -1), direction: 'south' },
            { position: new Position(-1, 0), direction: 'west' },
            { position: new Position(1, 0), direction: 'east' }
        ]

        let elvesPositions = parseInput(input);

        console.log({
            part2: scatterUntilNoMovement(elvesPositions, queue)
        })
    }
}